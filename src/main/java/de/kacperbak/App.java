/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package de.kacperbak;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class App {

    private static final int PAUSE_IN_MS = 2000;

    public static void main(String[] args) {
        try {
            var app = new App();
            var helloString = app.usingThenResult().get();
            System.out.println("helloString: " + helloString);
        } catch (Exception e) {
            System.out.println(e);
        }
    }

    /**
     * 1st Lambda: Supplier with no input parameter and a Future<string> as return type
     * 2nd Lambda: Accepts a function instance with parameters, processes the result and returns a Future<string>
     */
    public Future<String> usingThenApply() {
        var cf = CompletableFuture.supplyAsync(
                () -> {
                    threadSleep(PAUSE_IN_MS);
                    return "Hello";
                });
        return cf.thenApply(
                s -> {
                    threadSleep(PAUSE_IN_MS);
                    return s + " World!";
                });
    }

    /**
     * 1st Lambda: Supplier with no input parameter and a Future<string> as return type
     * 2nd Lambda: Accepts a function instance with parameters, processes the result and returns Void
     * @return
     */
    public CompletableFuture<Void> usingThenAccept() {
        var cf = CompletableFuture.supplyAsync(
                () -> {
                    return "Hello";
                });
        return cf.thenAccept(
                s -> {
                    System.out.printf(s + " World!");
                });
    }

    /**
     * 1st Lambda: Accepts a function instance with no parameters, processes the result and returns Void
     * 2nd Lambda: Accepts a function instance with no parameters, processes the result and returns Void
     * @return
     */
    public CompletableFuture<Void> usingThenResult() {
        var cf = CompletableFuture.runAsync(
                () -> {
                    System.out.printf("Hello World!");
                });
        return cf.thenRunAsync(
                () -> {
                    System.out.printf("Hello World!");
                });
    }

    /**
     * Lambda: Supplier with one input parameter and a Future<string> as return type
     */
    public Future<String> calculateAsyncWithSupplyAndParameter(String s) {
        return CompletableFuture.supplyAsync(() -> {
            threadSleep(PAUSE_IN_MS);
            return "Hello " + s;
        });
    }

    /**
     * Access to the threat pool underneath
     */
    public Future<String> calculateAsyncWithThreadPoolAccess() {
        CompletableFuture<String> completableFuture = new CompletableFuture<>();
        Executors.newCachedThreadPool().submit(() -> {
            threadSleep(PAUSE_IN_MS);
            completableFuture.complete("Hello World!");
            return null;
        });

        return completableFuture;
    }

    /**
     * This method encapsulates the IE exception that it is not propagated further
     * @param ms
     */
    private void threadSleep(int ms) {
        try {
            Thread.sleep(ms);
            System.out.printf("thread sleep for '%s' seconds.\n", (ms/1000));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
